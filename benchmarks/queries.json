[
  {
    "query": "What is CrabPath and what is it designed for?",
    "relevant": ["README.md"]
  },
  {
    "query": "How does CrabPath stay pure with no network calls and zero Python dependencies by default?",
    "relevant": ["README.md", "SKILL.md", "examples/hash_embedder/README.md"]
  },
  {
    "query": "How do I split markdown workspace content into a graph of chunks?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "Show the quick start flow for split_workspace with HashEmbedder and VectorIndex.",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "How can I use the default hash-v1 embedder in a local workflow?",
    "relevant": ["README.md", "SKILL.md", "examples/hash_embedder/README.md"]
  },
  {
    "query": "How do I plug in OpenAI embeddings when indexing workspace files?",
    "relevant": ["README.md", "examples/openai_embedder/README.md"]
  },
  {
    "query": "How do I replay historical queries to warm start a graph?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "How do I initialize state from a workspace using CLI?",
    "relevant": ["README.md"]
  },
  {
    "query": "How do I run semantic query retrieval with index search plus graph traversal?",
    "relevant": ["README.md"]
  },
  {
    "query": "How do keyword-seeded retrieval and overlap scoring work?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "What CLI commands are available for query, learn, health, replay, merge, and connect?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "What is stored in CrabPath's canonical state.json format?",
    "relevant": ["README.md", "SKILL.md", "REPRODUCE.md"]
  },
  {
    "query": "Which simulation claims can be reproduced and what do they validate?",
    "relevant": ["REPRODUCE.md"]
  },
  {
    "query": "How is deterministic behavior guaranteed in CrabPath simulations and benchmarks?",
    "relevant": ["README.md", "REPRODUCE.md", "SKILL.md"]
  },
  {
    "query": "What does the hash embedder example tell me to run?",
    "relevant": ["examples/hash_embedder/README.md", "README.md"]
  },
  {
    "query": "How do I run the OpenAI embedder example and what env setup does it need?",
    "relevant": ["examples/openai_embedder/README.md", "README.md"]
  },
  {
    "query": "How can I use sessions as replay input when using query history?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "What is the default hash embedder name and vector dimension?",
    "relevant": ["README.md", "SKILL.md"]
  },
  {
    "query": "Where are the paper references and reproducibility claims documented?",
    "relevant": ["REPRODUCE.md"]
  },
  {
    "query": "Can I run all reproducibility checks from one command line script?",
    "relevant": ["REPRODUCE.md"]
  },
  {
    "query": "What is the exact initialization order in `crabpath init` when sessions are passed, including replay timing versus embedding/index creation?",
    "relevant": ["crabpath/cli.py", "crabpath/split.py", "crabpath/replay.py"]
  },
  {
    "query": "What is the query replay sequence in CLI and when does `last_replayed_ts` prevent duplicate session processing?",
    "relevant": ["crabpath/cli.py", "crabpath/replay.py"]
  },
  {
    "query": "How does `apply_outcome` react differently to a missing edge when outcome is negative versus positive?",
    "relevant": ["crabpath/learn.py", "crabpath/graph.py"]
  },
  {
    "query": "In the PG learner, how are taken edges and non-taken edges weighted when updating a traversal path?",
    "relevant": ["crabpath/learn.py", "crabpath/traverse.py"]
  },
  {
    "query": "What does `apply_outcome_pg` change compared with `apply_outcome` after `traverse` on the same fired route?",
    "relevant": ["crabpath/learn.py", "crabpath/traverse.py"]
  },
  {
    "query": "How are inhibitory edges activated by incoming suppression during seed scoring versus later expansion in traversal?",
    "relevant": ["crabpath/traverse.py"]
  },
  {
    "query": "What traversal candidates are skipped when tier is dormant or inhibitory, and what happens to suppression scores below the threshold?",
    "relevant": ["crabpath/traverse.py", "crabpath/learn.py"]
  },
  {
    "query": "How does edge_damping prevent runaway revisits when the same edge is traversed repeatedly in one query?",
    "relevant": ["crabpath/traverse.py", "README.md"]
  },
  {
    "query": "What are the exact stop conditions in traversal for max_fired_nodes, max_context_chars, and stop_expanding flags?",
    "relevant": ["crabpath/traverse.py", "README.md"]
  },
  {
    "query": "How is split chunking selected for `.md`, `.py`, `.json`, and config-like files during workspace split?",
    "relevant": ["crabpath/split.py"]
  },
  {
    "query": "Which paths and patterns does split_workspace skip, including defaults, CLI excludes, and parsed .gitignore rules?",
    "relevant": ["crabpath/split.py"]
  },
  {
    "query": "How are adjacent chunk sibling edges weighted and inserted when a file is split?",
    "relevant": ["crabpath/split.py", "crabpath/graph.py"]
  },
  {
    "query": "How does split choose between heuristic chunking and LLM chunking, and how are failed LLM splits handled?",
    "relevant": ["crabpath/split.py"]
  },
  {
    "query": "What is the `crabpath inject` difference between TEACHING and CORRECTION with respect to inhibitory edge creation?",
    "relevant": ["crabpath/inject.py", "crabpath/cli.py"]
  },
  {
    "query": "How are existing inhibitory edges updated inside `_apply_inhibitory_edges` when injection re-targets the same node again?",
    "relevant": ["crabpath/inject.py", "crabpath/graph.py"]
  },
  {
    "query": "How does CLI query fall back from index search to keyword overlap and which argument path triggers fallback?",
    "relevant": ["crabpath/cli.py"]
  },
  {
    "query": "How do cross-file edges get identified in health and why do they matter for autotune?",
    "relevant": ["crabpath/autotune.py", "crabpath/cli.py", "crabpath/graph.py"]
  },
  {
    "query": "When dormant edge ratio is high, what knob suggestions can `autotune` emit and why?",
    "relevant": ["crabpath/autotune.py"]
  },
  {
    "query": "How does `replay_queries` compare edge snapshots to capture which edges were reinforced and which were newly cross-file?",
    "relevant": ["crabpath/replay.py", "crabpath/graph.py"]
  },
  {
    "query": "What is the candidate selection process for connect suggestions and why are same-file pairs ignored?",
    "relevant": ["crabpath/connect.py"]
  },
  {
    "query": "How does merge decide candidate sibling pairs and preserve strongest edges when rewiring a merged node?",
    "relevant": ["crabpath/merge.py", "crabpath/graph.py"]
  },
  {
    "query": "What cold-start workflow sequence is documented in examples for init, doctor, query, correction, injection, query again, and health verification?",
    "relevant": ["examples/cold_start/README.md", "crabpath/cli.py"]
  },
  {
    "query": "How does correction flow align fired nodes by chat_id and apply delayed corrections without losing the target route?",
    "relevant": ["examples/correction_flow/README.md", "examples/correction_flow/correct.py", "examples/correction_flow/query_with_logging.py"]
  },
  {
    "query": "How does the openclaw adapter rebuild brains from sessions and learning DB while applying correction inhibition?",
    "relevant": ["examples/openclaw_adapter/README.md", "examples/openclaw_adapter/init_agent_brain.py"]
  },
  {
    "query": "How is `replay` related to `query` and `learn` in the lifecycle for production learning workflows?",
    "relevant": ["README.md", "examples/openclaw_adapter/README.md", "SKILL.md"]
  }
]
